"""
Improved Training Data Generation for DeepStack Neural Network

This implements the proper data generation pipeline as described in:
- DeepStack paper Section S3.1
- DeepStack Supplementary Materials

The key insight: Training data comes from SOLVED poker situations, not random data.
Each training example is generated by:
1. Sampling a random poker situation (board, pot state, ranges)
2. Building a lookahead tree from that situation
3. Solving the tree with CFR (1000+ iterations)
4. Extracting the counterfactual values at root
5. Storing [inputs: ranges + pot state] -> [outputs: CFV values]

This is CRITICAL for DeepStack to work - the network learns to approximate
the result of deep CFR tree solving.

PERFORMANCE OPTIMIZATION:
- Uses fast rank-based equity approximation by default (100x speedup)
- Reuses single TerminalEquity instance across all samples
- For championship-level accuracy, use fast_approximation=False and pre-computed equity tables
"""

import numpy as np
import torch
import os
import sys
from typing import Tuple, Optional, List
from pathlib import Path

# Ensure project root and src/ are on sys.path and load .env PYTHONPATH
try:
    from dotenv import load_dotenv
    # .env is at repo root; this file is at src/deepstack/data/
    load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), '..', '..', '..', '.env'))
    pythonpath = os.environ.get("PYTHONPATH")
    if pythonpath:
        for p in pythonpath.split(os.pathsep):
            if p and p not in sys.path:
                sys.path.insert(0, p)
except Exception:
    pass

# Fallback: always add the repo's src/ directory
src_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if src_root not in sys.path:
    sys.path.insert(0, src_root)

# Now that src/ is on sys.path, import utilities
try:
    from deepstack.utils.hand_buckets import fractional_mask_169
except Exception as _e:
    # Fallback: attempt a relative import when executed as a script
    try:
        from ..utils.hand_buckets import fractional_mask_169  # type: ignore
    except Exception:
        raise


class ImprovedDataGenerator:
    """
    Generates training data by solving random poker situations.
    
    Per DeepStack paper Section S3.1:
    "We generate training data by sampling random poker situations and solving
    each with CFR. The neural network is then trained to predict these solutions."
    
    Championship-level enhancements:
    - Per-street bet sizing abstractions
    - Adaptive CFR iterations based on game complexity
    - Strategic range sampling
    """
    
    # Championship-level bet sizing per street (pot-relative)
    # Based on research from g5-poker-bot and DeepStack hand histories
    BET_SIZING_CHAMPIONSHIP = {
        0: [0.5, 1.0, 2.0, 4.0],           # Preflop: wider range including 3-bets, 4-bets
        1: [0.33, 0.5, 0.75, 1.0, 1.5],    # Flop: common c-bet sizes
        2: [0.5, 0.75, 1.0, 1.5],          # Turn: focused sizes
        3: [0.5, 0.75, 1.0, 2.0],          # River: polarized (value/bluff)
    }
    
    def __init__(self,
                 num_hands: int = 169,
                 cfr_iterations: int = 1000,
                 verbose: bool = True,
                 bucket_sampling_weights: Optional[np.ndarray] = None,
                 use_per_street_bet_sizing: bool = True,
                 use_adaptive_cfr: bool = False):
        """
        Initialize data generator.
        
        Args:
            num_hands: Number of hand buckets (169 for Texas Hold'em)
            cfr_iterations: CFR iterations per situation (paper uses 1000+, recommend 2000+)
            verbose: Print progress
            bucket_sampling_weights: Optional weights for biased bucket sampling
            use_per_street_bet_sizing: Use street-specific bet abstractions (championship-level)
            use_adaptive_cfr: Adjust CFR iterations based on situation complexity
        """
        self.num_hands = num_hands
        self.cfr_iterations = cfr_iterations
        self.verbose = verbose
        self.use_per_street_bet_sizing = use_per_street_bet_sizing
        self.use_adaptive_cfr = use_adaptive_cfr
        
        # Optional per-bucket sampling weights (length num_hands), non-negative. Used to bias range sampling.
        if bucket_sampling_weights is not None:
            w = np.asarray(bucket_sampling_weights, dtype=np.float64)
            if w.shape[0] != num_hands:
                raise ValueError(f"bucket_sampling_weights must have length {num_hands}, got {w.shape}")
            w = np.clip(w, 0.0, None)
            if w.sum() <= 0:
                w = np.ones_like(w)
            self.bucket_weights = (w / w.sum()).astype(np.float64)
        else:
            self.bucket_weights = None
        
        # Import here to avoid circular dependencies
        try:
            from deepstack.core.tree_builder import PokerTreeBuilder
            from deepstack.core.tree_cfr import TreeCFR
            from deepstack.core.terminal_equity import TerminalEquity

            self.tree_builder = PokerTreeBuilder(game_variant='holdem')
            # Use fast approximation for quick data generation (100x speedup)
            # For championship-level, set fast_approximation=False and pre-compute equity tables
            self.terminal_equity = TerminalEquity(game_variant='holdem', num_hands=num_hands, fast_approximation=True)
        except ImportError as e:
            if verbose:
                print(f"[WARNING] Could not import DeepStack components: {e}")
                print("[WARNING] Using placeholder generation (NOT championship-level)")
            self.tree_builder = None
    
    def sample_random_situation(self) -> dict:
        """
        Sample a random poker situation.
        
        Returns:
            Dict with keys: board, pot_state, player_range, opponent_range
        """
        # Bias sampling towards later streets for better coverage
        # DeepStack paper emphasizes training on all streets
        # Distribution: 20% preflop, 35% flop, 25% turn, 20% river
        num_board_cards = np.random.choice([0, 3, 4, 5], p=[0.20, 0.35, 0.25, 0.20])
        board = list(np.random.choice(52, num_board_cards, replace=False))
        
        # Sample random pot state
        # Street mapping: 0 cards -> 0 (preflop), 3 -> 1 (flop), 4 -> 2 (turn), 5 -> 3 (river)
        street_map = {0: 0, 3: 1, 4: 2, 5: 3}
        street = street_map.get(len(board), 0)
        if street == 0:
            # Preflop: small pot
            pot_state = {
                'street': 0,
                'bets': [np.random.randint(10, 50), np.random.randint(10, 50)],
                'current_player': np.random.choice([1, 2])
            }
        else:
            # Postflop: larger pots with more variance
            pot_base = 50 * (len(board) + 1)
            pot_variance = pot_base * 2
            pot_state = {
                'street': street,
                'bets': [np.random.randint(pot_base, pot_base + pot_variance), 
                        np.random.randint(pot_base, pot_base + pot_variance)],
                'current_player': np.random.choice([1, 2])
            }
        
        # Sample random ranges (initially uniform, add some variation)
        player_range = self._sample_range()
        opponent_range = self._sample_range()
        
        return {
            'board': board,
            'pot_state': pot_state,
            'player_range': player_range,
            'opponent_range': opponent_range
        }
    
    def _sample_range(self) -> np.ndarray:
        """Sample a range with optional bucket-weight bias.

        Strategy:
          - If bucket weights provided, draw a Dirichlet with alpha = base + scale * weights
            to bias probability mass towards targeted buckets, else fall back to uniform/dirichlet mix.
        """
        if self.bucket_weights is not None:
            base = 1.0  # base concentration
            scale = 8.0  # strength of bias
            alpha = base + scale * (self.bucket_weights * self.num_hands)
            # Numerical guard
            alpha = np.maximum(alpha, 1e-3)
            r = np.random.dirichlet(alpha)
            return r.astype(np.float32)
        # No weights: original behavior
        if np.random.random() < 0.7:
            return (np.ones(self.num_hands, dtype=np.float32) / self.num_hands)
        else:
            r = np.random.dirichlet(np.ones(self.num_hands, dtype=np.float64) * 2.0)
            return r.astype(np.float32)
    
    def _get_adaptive_cfr_iterations(self, street: int, pot_size: int) -> int:
        """
        Get adaptive CFR iterations based on situation complexity.
        
        Championship-level enhancement from g5-poker-bot insights:
        - Later streets need more iterations (larger game trees)
        - Bigger pots need more accuracy (more important situations)
        
        Args:
            street: Current street (0=preflop, 1=flop, 2=turn, 3=river)
            pot_size: Total pot size
            
        Returns:
            Number of CFR iterations for this situation
        """
        # Base iterations per street (later streets = bigger trees)
        base_iterations = {
            0: int(self.cfr_iterations * 0.75),  # Preflop: 75% of base
            1: int(self.cfr_iterations * 0.90),  # Flop: 90% of base
            2: int(self.cfr_iterations * 1.00),  # Turn: 100% of base
            3: int(self.cfr_iterations * 1.20),  # River: 120% of base
        }
        
        base = base_iterations.get(street, self.cfr_iterations)
        
        # Adjust for pot size (bigger pots = more important)
        # Normalize pot by stack size (1000 chips)
        pot_multiplier = 1.0 + min(pot_size / 1000.0, 0.3)  # Up to 30% increase
        
        return max(1000, int(base * pot_multiplier))  # Minimum 1000 iterations
    
    def solve_situation(self, situation: dict) -> Tuple[np.ndarray, np.ndarray]:
        """
        Solve a poker situation using CFR.
        
        Args:
            situation: Dict from sample_random_situation()
            
        Returns:
            Tuple of (inputs, targets):
            - inputs: [player_range, opponent_range, pot_features] 
            - targets: [player_cfvs, opponent_cfvs]
        """
        if self.tree_builder is None:
            # Fallback to placeholder (NOT correct, just for structure)
            return self._placeholder_solve(situation)
        
        # Build lookahead tree from situation
        street = situation['pot_state']['street']
        
        # Championship-level: Use per-street bet sizing if enabled
        if self.use_per_street_bet_sizing:
            bet_sizing = self.BET_SIZING_CHAMPIONSHIP.get(street, [1.0])
        else:
            bet_sizing = [1.0]  # Simple pot-sized bets
        
        tree_params = {
            'street': street,
            'bets': situation['pot_state']['bets'],
            'current_player': situation['pot_state']['current_player'],
            'board': situation['board'],
            'limit_to_street': True,
            'bet_sizing': bet_sizing
        }
        
        try:
            tree_root = self.tree_builder.build_tree(tree_params)
            
            # Adaptive CFR iterations based on situation complexity
            if self.use_adaptive_cfr:
                cfr_iters = self._get_adaptive_cfr_iterations(street, sum(situation['pot_state']['bets']))
            else:
                cfr_iters = self.cfr_iterations
            
            # Set up CFR solver with proper warmup (skip first 400 iterations for averaging)
            from deepstack.core.tree_cfr import TreeCFR
            # REUSE terminal equity instance (CRITICAL for performance - avoids recomputing equity matrices)
            skip_iters = max(200, cfr_iters // 5)  # Skip first 20% for strategy averaging
            cfr_solver = TreeCFR(skip_iterations=skip_iters, use_linear_cfr=True, use_cfr_plus=True, terminal_equity=self.terminal_equity)
            
            # Prepare starting ranges
            starting_ranges = np.array([
                situation['player_range'],
                situation['opponent_range']
            ])
            
            # Solve with CFR
            result = cfr_solver.run_cfr(tree_root, starting_ranges, cfr_iters)
            # Evaluate CFVs at root for both players using the current average strategy
            # Player 1 CFV vector at root
            player_cfvs = cfr_solver.evaluate_cfv(tree_root, starting_ranges, player=0)
            opponent_cfvs = cfr_solver.evaluate_cfv(tree_root, starting_ranges, player=1)
            
        except Exception as e:
            if self.verbose:
                print(f"[WARNING] CFR solve failed: {e}, using placeholder")
            return self._placeholder_solve(situation)
        
        # Prepare input features
        pot_size = sum(situation['pot_state']['bets'])
        pot_features = np.array([pot_size / 1000.0], dtype=np.float32)  # Normalize pot size
        # Street one-hot (0=pre,1=flop,2=turn,3=river)
        street = int(situation['pot_state'].get('street', 0))
        street_oh = np.zeros((4,), dtype=np.float32)
        if 0 <= street <= 3:
            street_oh[street] = 1.0
        # Board 52-card one-hot
        board_oh = np.zeros((52,), dtype=np.float32)
        for c in situation.get('board', []) or []:
            if 0 <= int(c) < 52:
                board_oh[int(c)] = 1.0
        
        inputs = np.concatenate([
            situation['player_range'].astype(np.float32),
            situation['opponent_range'].astype(np.float32), 
            pot_features,
            street_oh,
            board_oh
        ])
        
        # Prepare target values
        targets = np.concatenate([player_cfvs, opponent_cfvs])
        
        return inputs, targets
    
    def _placeholder_solve(self, situation: dict) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder solve (temporary - NOT championship-level).
        Used when CFR components not available.
        """
        pot_size = sum(situation['pot_state']['bets'])
        pot_features = np.array([pot_size / 1000.0], dtype=np.float32)
        # Street one-hot
        street = int(situation['pot_state'].get('street', 0))
        street_oh = np.zeros((4,), dtype=np.float32)
        if 0 <= street <= 3:
            street_oh[street] = 1.0
        # Board one-hot
        board_oh = np.zeros((52,), dtype=np.float32)
        for c in situation.get('board', []) or []:
            if 0 <= int(c) < 52:
                board_oh[int(c)] = 1.0
        
        inputs = np.concatenate([
            situation['player_range'].astype(np.float32),
            situation['opponent_range'].astype(np.float32), 
            pot_features,
            street_oh,
            board_oh
        ])
        
        # Placeholder targets (NOT correct - just for structure)
        targets = np.random.randn(2 * self.num_hands) * 10
        
        return inputs, targets
    
    def generate_dataset(self, 
                        num_samples: int,
                        output_path: str,
                        dataset_type: str = 'train') -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """
        Generate a complete dataset.
        
        Args:
            num_samples: Number of training examples to generate
            output_path: Path to save dataset
            dataset_type: 'train' or 'valid'
        """
        if self.verbose:
            print(f"Generating {dataset_type} dataset: {num_samples} samples")
            print(f"CFR iterations per sample: {self.cfr_iterations}")
        
        # Allocate arrays
        # Inputs now include: player_range (169), opponent_range (169), pot (1), street one-hot (4), board one-hot (52)
        input_size = 2 * self.num_hands + 1 + 4 + 52
        output_size = 2 * self.num_hands

        inputs = np.zeros((num_samples, input_size), dtype=np.float32)
        targets = np.zeros((num_samples, output_size), dtype=np.float32)
        masks = np.ones((num_samples, output_size), dtype=np.float32)
        streets = np.zeros((num_samples,), dtype=np.int64)

        # Generate samples with progress bar
        try:
            from tqdm import tqdm
            iterator = tqdm(range(num_samples), desc=f"Generating {dataset_type} samples", unit="sample")
        except ImportError:
            # Fallback if tqdm not available
            iterator = range(num_samples)
            if self.verbose:
                print(f"  Note: Install tqdm for progress bars (pip install tqdm)")
        
        for i in iterator:
            # Sample and solve random situation
            situation = self.sample_random_situation()
            inputs[i], targets[i] = self.solve_situation(situation)
            streets[i] = situation['pot_state']['street'] if 'pot_state' in situation else 0

            # Per-street board-aware fractional mask (169 per player -> tile to 2*169)
            board = situation.get('board', [])
            frac169 = np.array(fractional_mask_169(board), dtype=np.float32)
            if frac169.shape[0] != (self.num_hands):
                # Safety if num_hands != 169; fallback to ones
                per_player = np.ones((self.num_hands,), dtype=np.float32)
            else:
                per_player = frac169
            # Duplicate for both players
            masks[i, :self.num_hands] = per_player
            masks[i, self.num_hands:] = per_player

        if self.verbose:
            print(f"✓ {dataset_type} dataset generated (not yet saved)")
            print(f"  Inputs shape: {inputs.shape}")
            print(f"  Targets shape: {targets.shape}")

        return inputs, targets, masks, streets


def generate_training_data(train_count: int = 10000,
                          valid_count: int = 1000,
                          output_path: str = r'C:/Users/AMD/pokerbot/src/train_samples',
                          cfr_iterations: int = 2000,
                          bucket_sampling_weights: Optional[np.ndarray] = None,
                          use_championship_bet_sizing: bool = True,
                          use_adaptive_cfr: bool = False) -> None:
    """
    Main function to generate improved training data (Texas Hold'em only).
    
    Per DeepStack paper: Generate 10M+ training examples for Texas Hold'em. Each solved with 2000+ CFR iterations.
    
    Championship-level enhancements:
    - Per-street bet sizing abstractions (based on g5-poker-bot and DeepStack research)
    - Adaptive CFR iterations (optional - adjust based on situation complexity)
    
    Args:
        train_count: Number of training examples
        valid_count: Number of validation examples  
        output_path: Path to save data
        cfr_iterations: CFR iterations per sample (paper recommends 2000+, championship: 2500+)
        bucket_sampling_weights: Optional weights for adaptive bucket sampling
        use_championship_bet_sizing: Use per-street bet abstractions (recommended)
        use_adaptive_cfr: Adjust CFR iterations based on complexity (experimental)
    """
    num_hands = 169

    generator = ImprovedDataGenerator(
        num_hands=num_hands,
        cfr_iterations=cfr_iterations,
        verbose=True,
        bucket_sampling_weights=bucket_sampling_weights,
        use_per_street_bet_sizing=use_championship_bet_sizing,
        use_adaptive_cfr=use_adaptive_cfr
    )
    
    print("="*70)
    print("IMPROVED DATA GENERATION - DeepStack Paper Methodology")
    print("="*70)
    print(f"Num hands: {num_hands}")
    print(f"CFR iterations per sample: {cfr_iterations}")
    print(f"Training samples: {train_count}")
    print(f"Validation samples: {valid_count}")
    print(f"Championship bet sizing: {use_championship_bet_sizing}")
    print(f"Adaptive CFR iterations: {use_adaptive_cfr}")
    print("="*70)
    print()
    
    # Generate datasets in-memory
    valid_inputs, valid_targets, valid_masks, valid_streets = generator.generate_dataset(valid_count, output_path, 'valid')
    print()

    train_inputs, train_targets, train_masks, train_streets = generator.generate_dataset(train_count, output_path, 'train')
    print()

    # Compute target scaling statistics from TRAINING targets only (masked)
    eps = 1e-6
    # weights are fractional masks in [0,1]
    w = train_masks.astype(np.float64)
    x = train_targets.astype(np.float64)
    w_sum = np.clip(w.sum(axis=0), a_min=eps, a_max=None)
    target_mean = (w * x).sum(axis=0) / w_sum
    # Weighted variance
    var = (w * (x - target_mean) ** 2).sum(axis=0) / w_sum
    target_std = np.sqrt(np.maximum(var, eps*eps))

    # Apply standardization to both train and validation targets
    train_targets_std = (train_targets - target_mean) / target_std
    valid_targets_std = (valid_targets - target_mean) / target_std

    # Save tensors and scaling metadata
    os.makedirs(output_path, exist_ok=True)
    # Train
    torch.save(torch.from_numpy(train_inputs), os.path.join(output_path, 'train_inputs.pt'))
    torch.save(torch.from_numpy(train_targets_std), os.path.join(output_path, 'train_targets.pt'))
    torch.save(torch.from_numpy(train_masks), os.path.join(output_path, 'train_mask.pt'))
    torch.save(torch.from_numpy(train_streets), os.path.join(output_path, 'train_street.pt'))
    # Valid
    torch.save(torch.from_numpy(valid_inputs), os.path.join(output_path, 'valid_inputs.pt'))
    torch.save(torch.from_numpy(valid_targets_std), os.path.join(output_path, 'valid_targets.pt'))
    torch.save(torch.from_numpy(valid_masks), os.path.join(output_path, 'valid_mask.pt'))
    torch.save(torch.from_numpy(valid_streets), os.path.join(output_path, 'valid_street.pt'))
    # Scaling
    scaling = {
        'mean': torch.from_numpy(target_mean.astype(np.float32)),
        'std': torch.from_numpy(target_std.astype(np.float32))
    }
    torch.save(scaling, os.path.join(output_path, 'targets_scaling.pt'))
    # If sampling weights were used, save for provenance
    if bucket_sampling_weights is not None:
        try:
            import json as _json
            weights_path = os.path.join(output_path, 'bucket_sampling_weights.json')
            with open(weights_path, 'w') as f:
                _json.dump(list(map(float, bucket_sampling_weights)), f)
        except Exception:
            pass
    
    print("="*70)
    print("DATA GENERATION COMPLETE")
    print("="*70)
    print(f"Data saved to: {output_path}")
    print("Saved files:")
    print("  - train_inputs.pt, train_targets.pt (standardized), train_mask.pt, train_street.pt")
    print("  - valid_inputs.pt, valid_targets.pt (standardized), valid_mask.pt, valid_street.pt")
    print("  - targets_scaling.pt (mean/std for de-standardization)")
    print()
    print("IMPORTANT: This is an improved implementation following the paper.")
    print("For championship-level performance:")
    print("  - Generate 10M+ samples for Texas Hold'em (production)")
    print("="*70)


if __name__ == '__main__':
    import argparse as _argparse
    import json as _json
    parser = _argparse.ArgumentParser(description='Generate DeepStack training data')
    parser.add_argument('--train-count', type=int, default=1000)
    parser.add_argument('--valid-count', type=int, default=512)
    parser.add_argument('--cfr-iterations', type=int, default=2000)
    parser.add_argument('--output-path', type=str, default=r'C:/Users/AMD/pokerbot/src/train_samples')
    parser.add_argument('--bucket-weights-path', type=str, default='', help='Path to JSON file with 169 floats for bucket sampling weights')
    args = parser.parse_args()

    weights = None
    if args.bucket_weights_path:
        try:
            with open(args.bucket_weights_path, 'r') as f:
                arr = _json.load(f)
            weights = np.asarray(arr, dtype=np.float64)
        except Exception as _e:
            print(f"[WARN] Failed to read bucket weights: {args.bucket_weights_path} ({_e})")

    generate_training_data(
        train_count=args.train_count,
        valid_count=args.valid_count,
        output_path=args.output_path,
        cfr_iterations=args.cfr_iterations,
        bucket_sampling_weights=weights
    )
