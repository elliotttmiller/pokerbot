"""
Improved Training Data Generation for DeepStack Neural Network

This implements the proper data generation pipeline as described in:
- DeepStack paper Section S3.1
- DeepStack Supplementary Materials

The key insight: Training data comes from SOLVED poker situations, not random data.
Each training example is generated by:
1. Sampling a random poker situation (board, pot state, ranges)
2. Building a lookahead tree from that situation
3. Solving the tree with CFR (1000+ iterations)
4. Extracting the counterfactual values at root
5. Storing [inputs: ranges + pot state] -> [outputs: CFV values]

This is CRITICAL for DeepStack to work - the network learns to approximate
the result of deep CFR tree solving.
"""

import numpy as np
import torch
import os
import sys
from typing import Tuple, Optional
from pathlib import Path

# Ensure project root and src/ are on sys.path and load .env PYTHONPATH
try:
    from dotenv import load_dotenv
    # .env is at repo root; this file is at src/deepstack/data/
    load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), '..', '..', '..', '.env'))
    pythonpath = os.environ.get("PYTHONPATH")
    if pythonpath:
        for p in pythonpath.split(os.pathsep):
            if p and p not in sys.path:
                sys.path.insert(0, p)
except Exception:
    pass

# Fallback: always add the repo's src/ directory
src_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if src_root not in sys.path:
    sys.path.insert(0, src_root)

# Now that src/ is on sys.path, import utilities
try:
    from deepstack.utils.hand_buckets import fractional_mask_169
except Exception as _e:
    # Fallback: attempt a relative import when executed as a script
    try:
        from ..utils.hand_buckets import fractional_mask_169  # type: ignore
    except Exception:
        raise


class ImprovedDataGenerator:
    """
    Generates training data by solving random poker situations.
    
    Per DeepStack paper Section S3.1:
    "We generate training data by sampling random poker situations and solving
    each with CFR. The neural network is then trained to predict these solutions."
    """
    
    def __init__(self,
                 num_hands: int = 169,
                 cfr_iterations: int = 1000,
                 verbose: bool = True):
        """
        Initialize data generator.
        
        Args:
            num_hands: Number of hand buckets (169 for Texas Hold'em)
            cfr_iterations: CFR iterations per situation (paper uses 1000+)
            verbose: Print progress
        """
        self.num_hands = num_hands
        self.cfr_iterations = cfr_iterations
        self.verbose = verbose
        
        # Import here to avoid circular dependencies
        try:
            from deepstack.core.tree_builder import PokerTreeBuilder
            from deepstack.core.tree_cfr import TreeCFR
            from deepstack.core.terminal_equity import TerminalEquity

            self.tree_builder = PokerTreeBuilder(game_variant='holdem')
            self.terminal_equity = TerminalEquity(game_variant='holdem', num_hands=num_hands)
        except ImportError as e:
            if verbose:
                print(f"[WARNING] Could not import DeepStack components: {e}")
                print("[WARNING] Using placeholder generation (NOT championship-level)")
            self.tree_builder = None
    
    def sample_random_situation(self) -> dict:
        """
        Sample a random poker situation.
        
        Returns:
            Dict with keys: board, pot_state, player_range, opponent_range
        """
        # Always sample random board for Texas Hold'em (preflop, flop, turn, river)
        num_board_cards = np.random.choice([0, 3, 4, 5], p=[0.3, 0.4, 0.2, 0.1])
        board = list(np.random.choice(52, num_board_cards, replace=False))
        
        # Sample random pot state
        if len(board) == 0:
            # Preflop: small pot
            pot_state = {
                'street': 0,
                'bets': [np.random.randint(10, 50), np.random.randint(10, 50)],
                'current_player': np.random.choice([1, 2])
            }
        else:
            # Postflop: larger pots
            pot_base = 50 * (len(board) + 1)
            pot_state = {
                'street': len(board) // 3 + 1,
                'bets': [np.random.randint(pot_base, pot_base*3), 
                        np.random.randint(pot_base, pot_base*3)],
                'current_player': np.random.choice([1, 2])
            }
        
        # Sample random ranges (initially uniform, add some variation)
        player_range = self._sample_range()
        opponent_range = self._sample_range()
        
        return {
            'board': board,
            'pot_state': pot_state,
            'player_range': player_range,
            'opponent_range': opponent_range
        }
    
    def _sample_range(self) -> np.ndarray:
        """Sample a range (could be uniform or with variation)."""
        # For training diversity, sometimes use uniform, sometimes biased
        if np.random.random() < 0.7:
            # Uniform range
            return np.ones(self.num_hands) / self.num_hands
        else:
            # Slightly biased range (stronger hands more likely)
            range_weights = np.random.dirichlet(np.ones(self.num_hands) * 2)
            return range_weights
    
    def solve_situation(self, situation: dict) -> Tuple[np.ndarray, np.ndarray]:
        """
        Solve a poker situation using CFR.
        
        Args:
            situation: Dict from sample_random_situation()
            
        Returns:
            Tuple of (inputs, targets):
            - inputs: [player_range, opponent_range, pot_features] 
            - targets: [player_cfvs, opponent_cfvs]
        """
        if self.tree_builder is None:
            # Fallback to placeholder (NOT correct, just for structure)
            return self._placeholder_solve(situation)
        
        # Build lookahead tree from situation
        tree_params = {
            'street': situation['pot_state']['street'],
            'bets': situation['pot_state']['bets'],
            'current_player': situation['pot_state']['current_player'],
            'board': situation['board'],
            'limit_to_street': True,
            'bet_sizing': [1.0]  # Pot-sized bets
        }
        
        try:
            tree_root = self.tree_builder.build_tree(tree_params)
            
            # Set up CFR solver
            from deepstack.core.tree_cfr import TreeCFR
            from deepstack.core.terminal_equity import TerminalEquity
            # Initialize CFR with terminal equity (holdem, 169 buckets)
            te = TerminalEquity(game_variant='holdem', num_hands=self.num_hands)
            cfr_solver = TreeCFR(skip_iterations=min(200, self.cfr_iterations//5), use_linear_cfr=True, use_cfr_plus=True, terminal_equity=te)
            
            # Prepare starting ranges
            starting_ranges = np.array([
                situation['player_range'],
                situation['opponent_range']
            ])
            
            # Solve with CFR
            result = cfr_solver.run_cfr(tree_root, starting_ranges, self.cfr_iterations)
            # Evaluate CFVs at root for both players using the current average strategy
            # Player 1 CFV vector at root
            player_cfvs = cfr_solver.evaluate_cfv(tree_root, starting_ranges, player=0)
            opponent_cfvs = cfr_solver.evaluate_cfv(tree_root, starting_ranges, player=1)
            
        except Exception as e:
            if self.verbose:
                print(f"[WARNING] CFR solve failed: {e}, using placeholder")
            return self._placeholder_solve(situation)
        
        # Prepare input features
        pot_size = sum(situation['pot_state']['bets'])
        pot_features = np.array([pot_size / 1000.0], dtype=np.float32)  # Normalize pot size
        # Street one-hot (0=pre,1=flop,2=turn,3=river)
        street = int(situation['pot_state'].get('street', 0))
        street_oh = np.zeros((4,), dtype=np.float32)
        if 0 <= street <= 3:
            street_oh[street] = 1.0
        # Board 52-card one-hot
        board_oh = np.zeros((52,), dtype=np.float32)
        for c in situation.get('board', []) or []:
            if 0 <= int(c) < 52:
                board_oh[int(c)] = 1.0
        
        inputs = np.concatenate([
            situation['player_range'].astype(np.float32),
            situation['opponent_range'].astype(np.float32), 
            pot_features,
            street_oh,
            board_oh
        ])
        
        # Prepare target values
        targets = np.concatenate([player_cfvs, opponent_cfvs])
        
        return inputs, targets
    
    def _placeholder_solve(self, situation: dict) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder solve (temporary - NOT championship-level).
        Used when CFR components not available.
        """
        pot_size = sum(situation['pot_state']['bets'])
        pot_features = np.array([pot_size / 1000.0], dtype=np.float32)
        # Street one-hot
        street = int(situation['pot_state'].get('street', 0))
        street_oh = np.zeros((4,), dtype=np.float32)
        if 0 <= street <= 3:
            street_oh[street] = 1.0
        # Board one-hot
        board_oh = np.zeros((52,), dtype=np.float32)
        for c in situation.get('board', []) or []:
            if 0 <= int(c) < 52:
                board_oh[int(c)] = 1.0
        
        inputs = np.concatenate([
            situation['player_range'].astype(np.float32),
            situation['opponent_range'].astype(np.float32), 
            pot_features,
            street_oh,
            board_oh
        ])
        
        # Placeholder targets (NOT correct - just for structure)
        targets = np.random.randn(2 * self.num_hands) * 10
        
        return inputs, targets
    
    def generate_dataset(self, 
                        num_samples: int,
                        output_path: str,
                        dataset_type: str = 'train') -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """
        Generate a complete dataset.
        
        Args:
            num_samples: Number of training examples to generate
            output_path: Path to save dataset
            dataset_type: 'train' or 'valid'
        """
        if self.verbose:
            print(f"Generating {dataset_type} dataset: {num_samples} samples")
            print(f"CFR iterations per sample: {self.cfr_iterations}")
        
        # Allocate arrays
        # Inputs now include: player_range (169), opponent_range (169), pot (1), street one-hot (4), board one-hot (52)
        input_size = 2 * self.num_hands + 1 + 4 + 52
        output_size = 2 * self.num_hands

        inputs = np.zeros((num_samples, input_size), dtype=np.float32)
        targets = np.zeros((num_samples, output_size), dtype=np.float32)
        masks = np.ones((num_samples, output_size), dtype=np.float32)
        streets = np.zeros((num_samples,), dtype=np.int64)

        # Generate samples
        for i in range(num_samples):
            if self.verbose and (i + 1) % max(1, num_samples // 10) == 0:
                print(f"  Progress: {i+1}/{num_samples} samples generated")

            # Sample and solve random situation
            situation = self.sample_random_situation()
            inputs[i], targets[i] = self.solve_situation(situation)
            streets[i] = situation['pot_state']['street'] if 'pot_state' in situation else 0

            # Per-street board-aware fractional mask (169 per player -> tile to 2*169)
            board = situation.get('board', [])
            frac169 = np.array(fractional_mask_169(board), dtype=np.float32)
            if frac169.shape[0] != (self.num_hands):
                # Safety if num_hands != 169; fallback to ones
                per_player = np.ones((self.num_hands,), dtype=np.float32)
            else:
                per_player = frac169
            # Duplicate for both players
            masks[i, :self.num_hands] = per_player
            masks[i, self.num_hands:] = per_player

        if self.verbose:
            print(f"âœ“ {dataset_type} dataset generated (not yet saved)")
            print(f"  Inputs shape: {inputs.shape}")
            print(f"  Targets shape: {targets.shape}")

        return inputs, targets, masks, streets


def generate_training_data(train_count: int = 10000,
                          valid_count: int = 1000,
                          output_path: str = r'C:/Users/AMD/pokerbot/src/train_samples',
                          cfr_iterations: int = 1000) -> None:
    """
    Main function to generate improved training data (Texas Hold'em only).
    
    Per DeepStack paper: Generate 10M+ training examples for Texas Hold'em. Each solved with 1000+ CFR iterations.
    
    Args:
        train_count: Number of training examples
        valid_count: Number of validation examples  
        output_path: Path to save data
        cfr_iterations: CFR iterations per sample
    """
    num_hands = 169

    generator = ImprovedDataGenerator(
        num_hands=num_hands,
        cfr_iterations=cfr_iterations,
        verbose=True
    )
    
    print("="*70)
    print("IMPROVED DATA GENERATION - DeepStack Paper Methodology")
    print("="*70)
    print(f"Num hands: {num_hands}")
    print(f"CFR iterations per sample: {cfr_iterations}")
    print(f"Training samples: {train_count}")
    print(f"Validation samples: {valid_count}")
    print("="*70)
    print()
    
    # Generate datasets in-memory
    valid_inputs, valid_targets, valid_masks, valid_streets = generator.generate_dataset(valid_count, output_path, 'valid')
    print()

    train_inputs, train_targets, train_masks, train_streets = generator.generate_dataset(train_count, output_path, 'train')
    print()

    # Compute target scaling statistics from TRAINING targets only (masked)
    eps = 1e-6
    # weights are fractional masks in [0,1]
    w = train_masks.astype(np.float64)
    x = train_targets.astype(np.float64)
    w_sum = np.clip(w.sum(axis=0), a_min=eps, a_max=None)
    target_mean = (w * x).sum(axis=0) / w_sum
    # Weighted variance
    var = (w * (x - target_mean) ** 2).sum(axis=0) / w_sum
    target_std = np.sqrt(np.maximum(var, eps*eps))

    # Apply standardization to both train and validation targets
    train_targets_std = (train_targets - target_mean) / target_std
    valid_targets_std = (valid_targets - target_mean) / target_std

    # Save tensors and scaling metadata
    os.makedirs(output_path, exist_ok=True)
    # Train
    torch.save(torch.from_numpy(train_inputs), os.path.join(output_path, 'train_inputs.pt'))
    torch.save(torch.from_numpy(train_targets_std), os.path.join(output_path, 'train_targets.pt'))
    torch.save(torch.from_numpy(train_masks), os.path.join(output_path, 'train_mask.pt'))
    torch.save(torch.from_numpy(train_streets), os.path.join(output_path, 'train_street.pt'))
    # Valid
    torch.save(torch.from_numpy(valid_inputs), os.path.join(output_path, 'valid_inputs.pt'))
    torch.save(torch.from_numpy(valid_targets_std), os.path.join(output_path, 'valid_targets.pt'))
    torch.save(torch.from_numpy(valid_masks), os.path.join(output_path, 'valid_mask.pt'))
    torch.save(torch.from_numpy(valid_streets), os.path.join(output_path, 'valid_street.pt'))
    # Scaling
    scaling = {
        'mean': torch.from_numpy(target_mean.astype(np.float32)),
        'std': torch.from_numpy(target_std.astype(np.float32))
    }
    torch.save(scaling, os.path.join(output_path, 'targets_scaling.pt'))
    
    print("="*70)
    print("DATA GENERATION COMPLETE")
    print("="*70)
    print(f"Data saved to: {output_path}")
    print("Saved files:")
    print("  - train_inputs.pt, train_targets.pt (standardized), train_mask.pt, train_street.pt")
    print("  - valid_inputs.pt, valid_targets.pt (standardized), valid_mask.pt, valid_street.pt")
    print("  - targets_scaling.pt (mean/std for de-standardization)")
    print()
    print("IMPORTANT: This is an improved implementation following the paper.")
    print("For championship-level performance:")
    print("  - Generate 10M+ samples for Texas Hold'em (production)")
    print("="*70)


if __name__ == '__main__':
    # Example: Generate dataset for Texas Hold'em
    generate_training_data(
        train_count=1000,
        valid_count=512,  # Increased for robust validation and early stopping
        output_path=r'C:/Users/AMD/pokerbot/src/train_samples',
        cfr_iterations=1000
    )
